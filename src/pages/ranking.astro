---
Astro.response.headers.set("Cache-Control", "public, max-age=60, s-maxage=300");

import Main from "@/layouts/Main.astro";
import StandingsTable from "@/components/ranking/StandingsTable.astro";
import StandingsLegend from "@/components/ranking/StandingsLegend.astro";
import Title from "@/components/shared/Title.astro";
import Alert from "@/components/shared/Alert.astro";
import { Icon } from "astro-icon/components";
import { createAstroSupabase } from "@/lib/supabase"; // Usamos el cliente correcto

const supabase = createAstroSupabase(Astro);

// 1. Obtener Años Disponibles Dinámicamente
const { data: yearsData } = await supabase
  .from("view_player_stats_yearly")
  .select("year");
// Filtramos años únicos y ordenamos descendente (2025, 2024...)
const availableYears = [...new Set(yearsData?.map((y) => y.year))].sort(
  (a, b) => b - a
);
const currentYear = new Date().getFullYear().toString();
// Si no hay datos, usamos el año actual como fallback
const defaultYear =
  availableYears.length > 0 ? String(availableYears[0]) : currentYear;

// 2. URL Params
const sort = Astro.url.searchParams.get("sort") || "points";
const season = Astro.url.searchParams.get("season") || defaultYear;
const mode = Astro.url.searchParams.get("mode") || "simple";

// Construimos las opciones del selector incluyendo "Histórico"
const seasons = [...availableYears.map(String), "Histórico"];
// Si por alguna razón la lista está vacía (BD nueva), ponemos el año actual
if (seasons.length === 1) seasons.unshift(currentYear);

const sortOptions = [
  { value: "points", label: "Puntos" },
  { value: "name", label: "Nombre" },
  { value: "matches", label: "Partidos Jugados" },
  { value: "wins", label: "Victorias" },
  { value: "draws", label: "Empates" },
  { value: "losses", label: "Derrotas" },
  { value: "winRate", label: "% Victorias" },
  { value: "drawRate", label: "% Empates" },
  { value: "lossRate", label: "% Derrotas" },
];

// 3. Consulta SQL
let query;
if (season === "Histórico") {
  query = supabase.from("view_player_stats_all_time").select("*");
} else {
  query = supabase
    .from("view_player_stats_yearly")
    .select("*")
    .eq("year", season);
}

// Filtramos solo socios (no invitados)
// AHORA ESTO FUNCIONARÁ PORQUE LA VISTA YA TIENE 'is_guest'
const { data: rawPlayers, error } = await query.eq("is_guest", false);

const hasError = !!error;
const hasPlayersStats = !hasError && rawPlayers && rawPlayers.length > 0;

// 4. Mapeo de datos
const players =
  rawPlayers?.map((p) => ({
    ...p,
    matches: p.matches_played,
    // Mapeamos los campos nuevos de la vista SQL
    attendance_percentage: p.attendance_pct || 0,

    // IMPORTANTE: Para la TABLA (StandingsTable), pasamos las Tasas Reales
    win_pct: p.win_rate || 0, // % de Victorias (Matches Won / Played)
    draw_pct: p.draw_rate || 0, // % de Empates
    loss_pct: p.loss_rate || 0, // % de Derrotas

    // Pasamos el array de forma
    form_array: p.form_array || [],

    // Guardamos la efectividad real por si la necesitamos para ordenar
    effectiveness: p.effectiveness || 0,
  })) || [];

// 5. Ordenamiento
const sortedPlayers = [...players].sort((a, b) => {
  switch (sort) {
    case "name":
      return a.nickname.localeCompare(b.nickname);
    case "matches":
      return b.matches - a.matches;
    case "wins":
      return b.wins - a.wins;
    case "draws":
      return b.draws - a.draws;
    case "losses":
      return b.losses - a.losses;
    case "attendance":
      return b.attendance_percentage - a.attendance_percentage;
    // Ordenar por porcentajes usa las tasas
    case "winRate":
      return b.win_pct - a.win_pct;
    case "drawRate":
      return b.draw_pct - a.draw_pct;
    case "lossRate":
      return b.loss_pct - a.loss_pct;
    default:
      // Criterio por defecto: Puntos > Efectividad (no win_rate) > Partidos
      if (b.points !== a.points) return b.points - a.points;
      if (b.effectiveness !== a.effectiveness)
        return b.effectiveness - a.effectiveness;
      return b.matches - a.matches;
  }
});
---

<Main title="Clasificación | SGSC">
  <Title
    title="Clasificación"
    subtitle={season === "Histórico"
      ? "Histórico Global"
      : `Temporada ${season}`}
  />

  <div
    class="bg-base-100 border-base-200 mb-6 flex flex-col gap-2 rounded-xl border p-4 shadow-md sm:flex-row sm:items-center sm:gap-4"
  >
    <div
      class="flex w-full flex-col gap-4 sm:flex-row sm:items-center sm:justify-between"
    >
      {/* Selector de Temporada */}
      <div class="form-control w-full">
        <label class="label py-1">
          <span
            class="label-text text-base-content/60 text-xs font-bold uppercase"
            >Temporada</span
          >
        </label>
        <select
          id="season"
          class="select select-bordered select-sm md:select-md w-full rounded-xl"
        >
          {
            seasons.map((s) => (
              <option value={s} selected={String(season) === String(s)}>
                {s}
              </option>
            ))
          }
        </select>
      </div>

      {/* Selector de Orden */}
      <div class="form-control w-full">
        <label class="label py-1">
          <span
            class="label-text text-base-content/60 text-xs font-bold uppercase"
            >Ordenar por</span
          >
        </label>
        <select
          id="sort"
          class="select select-bordered select-sm md:select-md w-full rounded-xl"
        >
          {
            sortOptions.map((o) => (
              <option value={o.value} selected={sort === o.value}>
                {o.label}
              </option>
            ))
          }
        </select>
      </div>
    </div>

    <div class="divider m-0 sm:hidden"></div>

    {/* Toggle Vista Detallada (Móvil) */}
    <div class="form-control w-full sm:hidden">
      <label class="label cursor-pointer justify-start gap-3 p-0">
        <span class="text-base-content/60 text-xs font-bold uppercase"
          >Vista Detallada</span
        >
        <input
          id="mode-toggle"
          type="checkbox"
          class="toggle toggle-primary toggle-sm"
          checked={mode === "detailed"}
        />
      </label>
    </div>
  </div>

  {/* Error de conexión */}
  {
    hasError && (
      <Alert
        type="error"
        message="No se pudo cargar la clasificación. Por favor, intenta más tarde."
      />
    )
  }

  {/* Sin datos para la temporada */}
  {
    !hasError && !hasPlayersStats && (
      <Alert
        type="warning"
        message={`No hay partidos registrados para la temporada ${season}.`}
      />
    )
  }

  {/* Tabla de clasificación */}
  {
    hasPlayersStats && (
      <div class="animate-fade-in space-y-6">
        <StandingsTable
          players={sortedPlayers}
          showDetails={mode === "detailed"}
        />
        <StandingsLegend />
      </div>
    )
  }
</Main>

<script>
  const s = document.getElementById("season") as HTMLSelectElement;
  const o = document.getElementById("sort") as HTMLSelectElement;
  const m = document.getElementById("mode-toggle") as HTMLInputElement;

  const update = () => {
    const url = new URL(window.location.href);
    if (s) url.searchParams.set("season", s.value);
    if (o) url.searchParams.set("sort", o.value);
    if (m) url.searchParams.set("mode", m.checked ? "detailed" : "simple");
    window.location.href = url.toString();
  };

  s?.addEventListener("change", update);
  o?.addEventListener("change", update);
  m?.addEventListener("change", update);
</script>
